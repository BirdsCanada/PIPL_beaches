---
title: "analyzeData"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(lme4)
library(optimx)
library(DHARMa)
library(glmmTMB)

mod_human<-read.csv(file = '../Data/temporalMod.csv') %>% 
  select(-1)
mod_phys<-read.csv(file = '../Data/spatialMod.csv') %>% 
  select(-1)
```

## Stats Plan Ideas/Notes

Model with all beaches data (CWS prod data and physical data)
-maybe use a category of always has pipls, never has pipls, sometimes has pipls
- prod_var ~ Length_km + beachArea + urban_percent + agr_percent + road_percent + beach_forage + *beach width(?)* + (1|Year) + (1|BeachID) ?????
- this model would cover physical characteristics only
- look into how we can do effect size, could drop factors and look at variation explained and it's change (sensu Sarah paper)
- serious con of not being able to compare effect size of diff types within a model
- probably over-paramaterized

Human survey data
- could model based on categorical productivity variable to assess what's important
- could just summarize and put into a more generic model (base off BRC)
- If I model this it could help direct the BRC, what should we rate
- nested model BeachID/Year, can have specific human summary variables per beach per year

Overall model
- Should I try to do one big model??
- split into types of factors? human, physical, environmental? One model each?



## Models

### Spatial Models
```{r poisson regression}
hist(mod_phys$max_BP)
mean(mod_phys$max_BP, na.rm = TRUE) #1.559
var(mod_phys$max_BP, na.rm = TRUE) #3.044

m2<-glm(max_BP ~ BeachArea_km + beach_width + Length_km + parkArea + bufferPop_km2 + Border_road + tot_area_km_Beach + developedLand + Management + Region, data = mod_phys, family = poisson(link = "log")) # no error
drop1(m1)

m2<-glm(max_BP ~ BeachArea_km + beach_width + Length_km + parkArea + bufferPop_km2 + Border_road + tot_area_km_Beach + developedLand + Region, data = mod_phys, family = poisson(link = "log"))#no error
drop1(m2)

m3<-glm(max_BP ~ beach_width + Length_km + parkArea + bufferPop_km2 + Border_road + tot_area_km_Beach + developedLand + Region, data = mod_phys, family = poisson(link = "log"))#no error
drop1(m3)

m4<-glm(max_BP ~ beach_width + Length_km + parkArea + bufferPop_km2 + tot_area_km_Beach + developedLand + Region, data = mod_phys, family = poisson(link = "log"))#no error
drop1(m4)

m5<-glm(max_BP ~ beach_width + Length_km  + bufferPop_km2 + tot_area_km_Beach + developedLand + Region, data = mod_phys, family = poisson(link = "log"))#no error
drop1(m5)

m6<-glm(max_BP ~ beach_width + Length_km  + bufferPop_km2 + tot_area_km_Beach + Region, data = mod_phys, family = poisson(link = "log"))#no error
drop1(m6)

m7<-glm(max_BP ~ beach_width + Length_km  + bufferPop_km2 + Region, data = mod_phys, family = poisson(link = "log"))#no error
drop1(m7) #dropping factors after this no longer improves AIC

summary(m7)
```


```{r model validation}

#model structure max_BP ~ BeachArea_km + beach_width + Length_km + parkArea + bufferPop_km2 + Border_road + tot_area_km_Beach + developedLand + Management + Region
# with DHARMa

simOutput <- simulateResiduals(fittedModel = m7, plot = T)
#some quantile deviations, fitted value plot n.s. and the effect is quite small, I'm okay with this model (DHARMa documentation)

#tested zero inflation because we have a lot of 0 presence observations
testZeroInflation(simOutput) #this is okay, n.s. and well within the distribution

#overdispersion is a common issue with poisson
testDispersion(simOutput, type = "PearsonChisq") #okay

```


```{r spatial model effect size}
sjPlot::plot_model(m7, show.values = TRUE, axis.lim = c(.001,1000), sort.est = TRUE, value.offset = .3)

```



```{r productivity models}
hist(mod_phys$avg_productivity)
mean(mod_phys$avg_productivity, na.rm = TRUE) #1.555
var(mod_phys$avg_productivity, na.rm = TRUE) #1.550

hist(log10(mod_phys$avg_productivity))

mod.data.p<-mod_phys #%>% 
  #filter(avg_productivity>0)

#can't use poisson distributions because they're non-integer values
mp1<-lm(max_BP ~ BeachArea_km + beach_width + Length_km + parkArea + bufferPop_km2 + Border_road + tot_area_km_Beach + developedLand + Management + Region, data = mod.data.p)
drop1(mp1)

mp2<-lm(max_BP ~ BeachArea_km + beach_width + Length_km + parkArea + bufferPop_km2 + Border_road + tot_area_km_Beach + developedLand + Region, data = mod.data.p)
drop1(mp2)

mp3<-lm(max_BP ~ BeachArea_km + beach_width + Length_km + parkArea + bufferPop_km2  + tot_area_km_Beach + developedLand + Region, data = mod.data.p)
drop1(mp3)

mp4<-lm(max_BP ~ BeachArea_km + beach_width + Length_km + bufferPop_km2  + tot_area_km_Beach + developedLand + Region, data = mod.data.p)
drop1(mp4)

mp5<-lm(max_BP ~  beach_width + Length_km + bufferPop_km2  + tot_area_km_Beach + developedLand + Region, data = mod.data.p)
drop1(mp5)

mp6<-lm(max_BP ~  beach_width + Length_km + bufferPop_km2 + developedLand + Region, data = mod.data.p)
drop1(mp6)

mp7<-lm(max_BP ~  beach_width + Length_km + bufferPop_km2 + Region, data = mod.data.p)
drop1(mp7)

mp8<-lm(max_BP ~  beach_width + Length_km  + Region, data = mod.data.p)
drop1(mp8)

summary(mp8) #same interpretation as max_BP with all data, excluding 0s same except pop density removed in optimal model
```

### Human Model

fitted following Zuur (2009) methods

```{r random factor selection}
#rescale numerical variables
numcols<-which(sapply(mod_human[,1:23], is.numeric)) #don't rescale response variables for the poisson distribution (no negatives)
mod_humanSc<-mod_human
mod_humanSc[,numcols] <- scale(mod_humanSc[,numcols])

mean(mod.data$YE_pairs)
var(mod.data$YE_pairs)

mod.data<-mod_humanSc %>% 
  select(BeachID:Year, signs_small:vehicles, dogs_unleashedTotal:dogs_all, peopleIntensity, County, YE_pairs) %>% 
  na.omit()
#with scaled variables
#assess random factor structure first
mh1<-glmer(YE_pairs ~ signs_small + signs_large + vehicles + dogs_all + peopleIntensity + dogs_unleashedTotal +  fencedNests + (1|Year) + (1|BeachID), data = mod.data, family = poisson(link = "log"), control = glmerControl(optimizer ='optimx', optCtrl=list(method='nlminb')))
#no error

mh2<-glmer(YE_pairs ~ signs_small + signs_large + vehicles + dogs_all + peopleIntensity + dogs_unleashedTotal +  fencedNests + Year + (1|BeachID), data = mod.data, family = poisson(link = "log"), control = glmerControl(optimizer ='optimx', optCtrl=list(method='nlminb')))
#no error

mh3<-glmer(YE_pairs ~ signs_small + signs_large + vehicles + dogs_all + peopleIntensity + dogs_unleashedTotal +  fencedNests + (1|County) + (1|Year) + (1|BeachID), data = mod.data, family = poisson(link = "log"), control = glmerControl(optimizer ='optimx', optCtrl=list(method='nlminb')))
#no error

mh4<-glmer(YE_pairs ~ signs_small + signs_large + vehicles + dogs_all + peopleIntensity + dogs_unleashedTotal +  fencedNests + (1|County) + (1|BeachID), data = mod.data, family = poisson(link = "log"), control = glmerControl(optimizer ='optimx', optCtrl=list(method='nlminb')))
# no error

#compare AIC values to pick random structure?
summary(mh1) #637.9
summary(mh2) #633.9
summary(mh3) #631.2
summary(mh4) #629.2 #best value

```

YE_pairs ~ signs_small + signs_large + vehicles + dogs_all + peopleIntensity + dogs_unleashedTotal +  fencedNests
```{r fixed factor selection}
drop1(mh4, test = "Chi")

mh5<-glmer(YE_pairs ~ signs_small + signs_large + dogs_all + peopleIntensity + dogs_unleashedTotal +  fencedNests + (1|County) + (1|BeachID), data = mod.data, family = poisson(link = "log"), control = glmerControl(optimizer ='optimx', optCtrl=list(method='nlminb')))
drop1(mh5, test = "Chi")

mh6<-glmer(YE_pairs ~ signs_small + signs_large + dogs_all + peopleIntensity +  fencedNests + (1|County) + (1|BeachID), data = mod.data, family = poisson(link = "log"), control = glmerControl(optimizer ='optimx', optCtrl=list(method='nlminb')))
drop1(mh6, test = "Chi")

mh7<-glmer(YE_pairs ~ signs_small + signs_large + peopleIntensity +  fencedNests + (1|County) + (1|BeachID), data = mod.data, family = poisson(link = "log"), control = glmerControl(optimizer ='optimx', optCtrl=list(method='nlminb')))
drop1(mh7, test = "Chi")

summary(mh7)

```


```{r model validations}
simOutput <- simulateResiduals(fittedModel = mh7, plot = T) #bad for uniformity and quantiles

testDispersion(mh7, type = "PearsonChisq") #not okay
testZeroInflation(mh4) #okay

#for the variables
plotResiduals(simOutput, form = mod.data$signs_small)
plotResiduals(simOutput, form = mod.data$signs_large)
plotResiduals(simOutput, form = mod.data$peopleIntensity)
plotResiduals(simOutput, form = mod.data$fencedNests)
plotResiduals(simOutput, form = mod.data$BeachID) #n.s. okay
plotResiduals(simOutput, form = mod.data$County) #also okay n.s. only a few groups non-uniform

```


```{r fixing singularity old}
library("numDeriv")
library("reshape2")
library("afex")

mod<-glmer(YE_pairs ~ signs_small + signs_large + vehicles + dogs_all + peopleIntensity + offleash_ind + County + fencedNests + (1|BeachID), data = mod_humanSc, family = poisson(link = "log"), control = glmerControl(optimizer ='optimx', optCtrl=list(method='nlminb')))
summary(mod)

tt <- getME(mod,"theta")
ll <- getME(mod,"lower")
min(tt[ll==0]) #def singular

#checking gradient calculations
derivs1 <- mod_sc@optinfo$derivs
sc_grad1 <- with(derivs1,solve(Hessian,gradient))
max(abs(sc_grad1))

max(pmin(abs(sc_grad1),abs(derivs1$gradient))) #below the tolerance of .001 so this is good!

#more iterations?
ss <- getME(mod_sc,c("theta","fixef"))
mod2 <- update(mod_sc,start=ss,control=glmerControl(optCtrl=list(maxfun=2e4))) #still singular


```


